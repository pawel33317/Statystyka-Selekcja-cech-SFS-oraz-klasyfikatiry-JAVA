
import java.io.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Vector;
import javax.swing.*;
import javax.swing.filechooser.FileNameExtensionFilter;
import Jama.*;
import static java.lang.Math.*;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;
/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * PR_GUI.java
 *
 * Created on 2013-03-05, 19:40:56
 */
/**
 *
 * @author krzy
 */
public class PR_GUI extends javax.swing.JFrame {

    String InData; // dataset from a text file will be placed here
    int ClassCount = 0, FeatureCount = 0;
    double[][] F, FNew; // original feature matrix and transformed feature matrix
    int[] ClassLabels, SampleCount;
    String[] ClassNames;
    double Ftrain[][];
    double Ftest[][];
    int FtrainSeparator;
    int FtrainSeparator2[];
    int FtrainSeparator2test[];
    DefaultListModel listModel1;
    List<int[]> listaBezPowt = new ArrayList<int[]>();

    /**
     * Creates new form PR_GUI
     */
    public PR_GUI() {
        initComponents();
        setSize(940, 410);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        rbg_F = new javax.swing.ButtonGroup();
        b_read = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        l_dataset_name_l = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        l_dataset_name = new javax.swing.JLabel();
        l_nfeatures = new javax.swing.JLabel();
        jButton2 = new javax.swing.JButton();
        jPanel3 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        jLabel6 = new javax.swing.JLabel();
        selbox_nfeat = new javax.swing.JComboBox();
        jSeparator1 = new javax.swing.JSeparator();
        f_rb_extr = new javax.swing.JRadioButton();
        f_rb_sel = new javax.swing.JRadioButton();
        b_deriveFS = new javax.swing.JButton();
        jLabel10 = new javax.swing.JLabel();
        f_combo_criterion = new javax.swing.JComboBox();
        f_combo_PCA_LDA = new javax.swing.JComboBox();
        jLabel12 = new javax.swing.JLabel();
        tf_PCA_Energy = new javax.swing.JTextField();
        jLabel14 = new javax.swing.JLabel();
        jLabel15 = new javax.swing.JLabel();
        l_NewDim = new javax.swing.JLabel();
        f_rb_sel1 = new javax.swing.JRadioButton();
        jPanel1 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jList1 = new javax.swing.JList();
        jPanel4 = new javax.swing.JPanel();
        jLabel8 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jComboBox2 = new javax.swing.JComboBox();
        b_Train = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jLabel16 = new javax.swing.JLabel();
        tf_winSize = new javax.swing.JTextField();
        testLAbel = new javax.swing.JLabel();
        testLAbel1 = new javax.swing.JLabel();
        testLAbel2 = new javax.swing.JLabel();
        jLabel18 = new javax.swing.JLabel();
        tf_TrainSetSize1 = new javax.swing.JTextField();
        jLabel19 = new javax.swing.JLabel();
        jPanel5 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        l_FLD_winner = new javax.swing.JLabel();
        jLabel13 = new javax.swing.JLabel();
        l_FLD_val = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        getContentPane().setLayout(null);

        b_read.setText("Read dataset");
        b_read.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_readActionPerformed(evt);
            }
        });
        getContentPane().add(b_read);
        b_read.setBounds(20, 10, 130, 20);

        jPanel2.setBackground(new java.awt.Color(204, 255, 255));
        jPanel2.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jLabel1.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
        jLabel1.setText("Dataset info");

        l_dataset_name_l.setText("Name:");

        jLabel3.setText("Classes:");

        jLabel4.setText("Features:");

        l_dataset_name.setText("...");

        l_nfeatures.setText("...");

        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addComponent(l_dataset_name_l)
                        .addGap(18, 18, 18)
                        .addComponent(l_dataset_name))
                    .addComponent(jLabel1))
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(115, 115, 115)
                        .addComponent(jLabel3))
                    .addGroup(jPanel2Layout.createSequentialGroup()
                        .addGap(94, 94, 94)
                        .addComponent(jLabel4)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(l_nfeatures)))
                .addGap(100, 100, 100))
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel2Layout.createSequentialGroup()
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel1)
                    .addComponent(jLabel3))
                .addGap(10, 10, 10)
                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(l_dataset_name_l)
                    .addComponent(jLabel4)
                    .addComponent(l_dataset_name)
                    .addComponent(l_nfeatures))
                .addContainerGap(24, Short.MAX_VALUE))
        );

        getContentPane().add(jPanel2);
        jPanel2.setBounds(10, 50, 320, 80);

        jButton2.setText("Parse dataset");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });
        getContentPane().add(jButton2);
        jButton2.setBounds(190, 10, 130, 23);

        jPanel3.setBackground(new java.awt.Color(255, 255, 204));
        jPanel3.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel3.setLayout(null);

        jLabel5.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
        jLabel5.setText("Feature space");
        jPanel3.add(jLabel5);
        jLabel5.setBounds(14, 2, 118, 26);

        jLabel6.setText("FS Dimension");
        jPanel3.add(jLabel6);
        jLabel6.setBounds(178, 9, 63, 14);

        selbox_nfeat.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20" }));
        jPanel3.add(selbox_nfeat);
        selbox_nfeat.setBounds(249, 6, 50, 20);
        jPanel3.add(jSeparator1);
        jSeparator1.setBounds(14, 41, 290, 10);

        f_rb_extr.setBackground(new java.awt.Color(255, 255, 204));
        rbg_F.add(f_rb_extr);
        f_rb_extr.setText("Feature extraction");
        f_rb_extr.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                f_rb_extrActionPerformed(evt);
            }
        });
        jPanel3.add(f_rb_extr);
        f_rb_extr.setBounds(10, 110, 115, 23);

        f_rb_sel.setBackground(new java.awt.Color(255, 255, 204));
        rbg_F.add(f_rb_sel);
        f_rb_sel.setSelected(true);
        f_rb_sel.setText("Feature selection");
        f_rb_sel.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                f_rb_selActionPerformed(evt);
            }
        });
        jPanel3.add(f_rb_sel);
        f_rb_sel.setBounds(10, 60, 109, 23);

        b_deriveFS.setText("Derive Feature Space");
        b_deriveFS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_deriveFSActionPerformed(evt);
            }
        });
        jPanel3.add(b_deriveFS);
        b_deriveFS.setBounds(10, 180, 292, 23);

        jLabel10.setText("Criterion");
        jPanel3.add(jLabel10);
        jLabel10.setBounds(200, 50, 41, 14);

        f_combo_criterion.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Fisher discriminant", "Classification error" }));
        f_combo_criterion.setEnabled(false);
        f_combo_criterion.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                f_combo_criterionActionPerformed(evt);
            }
        });
        jPanel3.add(f_combo_criterion);
        f_combo_criterion.setBounds(160, 70, 140, 20);

        f_combo_PCA_LDA.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "PCA", "LDA" }));
        f_combo_PCA_LDA.setEnabled(false);
        jPanel3.add(f_combo_PCA_LDA);
        f_combo_PCA_LDA.setBounds(190, 110, 70, 20);

        jLabel12.setText("Energy");
        jPanel3.add(jLabel12);
        jLabel12.setBounds(20, 150, 34, 14);

        tf_PCA_Energy.setText("80");
        jPanel3.add(tf_PCA_Energy);
        tf_PCA_Energy.setBounds(70, 150, 30, 20);

        jLabel14.setText("%");
        jPanel3.add(jLabel14);
        jLabel14.setBounds(110, 150, 20, 14);

        jLabel15.setText("New dimension:");
        jPanel3.add(jLabel15);
        jLabel15.setBounds(160, 150, 75, 14);

        l_NewDim.setText("...");
        jPanel3.add(l_NewDim);
        l_NewDim.setBounds(270, 150, 30, 14);

        f_rb_sel1.setBackground(new java.awt.Color(255, 255, 204));
        rbg_F.add(f_rb_sel1);
        f_rb_sel1.setText("Feature selection");
        f_rb_sel1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                f_rb_sel1ActionPerformed(evt);
            }
        });
        jPanel3.add(f_rb_sel1);
        f_rb_sel1.setBounds(10, 60, 109, 23);

        getContentPane().add(jPanel3);
        jPanel3.setBounds(10, 140, 320, 220);

        jPanel1.setBackground(new java.awt.Color(255, 255, 255));
        jPanel1.setBorder(javax.swing.BorderFactory.createEtchedBorder());

        jList1.setModel(new javax.swing.AbstractListModel() {
            String[] strings = { "Item 1", "Item 2", "Item 3", "Item 4", "Item 5" };
            public int getSize() { return strings.length; }
            public Object getElementAt(int i) { return strings[i]; }
        });
        jScrollPane1.setViewportView(jList1);

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 316, Short.MAX_VALUE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 108, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        getContentPane().add(jPanel1);
        jPanel1.setBounds(580, 10, 340, 130);

        jPanel4.setBackground(new java.awt.Color(204, 255, 204));
        jPanel4.setBorder(javax.swing.BorderFactory.createEtchedBorder());
        jPanel4.setLayout(null);

        jLabel8.setFont(new java.awt.Font("Comic Sans MS", 0, 18)); // NOI18N
        jLabel8.setText("Classifier");
        jPanel4.add(jLabel8);
        jLabel8.setBounds(10, 0, 79, 26);

        jLabel9.setText("Method");
        jPanel4.add(jLabel9);
        jLabel9.setBounds(14, 44, 130, 14);

        jComboBox2.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "Nearest neighbor (NN)", "Nearest Mean (NM)", "k-Nearest Neighbor (k-NN)", "k-Nearest Mean (k-NM)" }));
        jComboBox2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox2ActionPerformed(evt);
            }
        });
        jPanel4.add(jComboBox2);
        jComboBox2.setBounds(230, 40, 152, 20);

        b_Train.setText("Train");
        b_Train.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                b_TrainActionPerformed(evt);
            }
        });
        jPanel4.add(b_Train);
        b_Train.setBounds(20, 130, 98, 23);

        jButton4.setText("Execute");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });
        jPanel4.add(jButton4);
        jButton4.setBounds(270, 130, 96, 23);

        jLabel16.setText("K-wygranych");
        jPanel4.add(jLabel16);
        jLabel16.setBounds(410, 140, 80, 14);

        tf_winSize.setText("3");
        tf_winSize.setEnabled(false);
        jPanel4.add(tf_winSize);
        tf_winSize.setBounds(490, 140, 20, 20);

        testLAbel.setText("Wszystkie");
        jPanel4.add(testLAbel);
        testLAbel.setBounds(30, 70, 300, 14);

        testLAbel1.setText("Treningowe");
        jPanel4.add(testLAbel1);
        testLAbel1.setBounds(30, 90, 300, 14);

        testLAbel2.setText("Testowe");
        jPanel4.add(testLAbel2);
        testLAbel2.setBounds(30, 110, 300, 14);

        jLabel18.setText("Training part:");
        jPanel4.add(jLabel18);
        jLabel18.setBounds(20, 170, 80, 14);

        tf_TrainSetSize1.setText("80");
        jPanel4.add(tf_TrainSetSize1);
        tf_TrainSetSize1.setBounds(110, 170, 20, 20);

        jLabel19.setText("%");
        jPanel4.add(jLabel19);
        jLabel19.setBounds(140, 170, 20, 14);

        getContentPane().add(jPanel4);
        jPanel4.setBounds(340, 150, 580, 210);

        jPanel5.setBorder(javax.swing.BorderFactory.createTitledBorder("Results"));
        jPanel5.setLayout(null);

        jLabel2.setText("FS Winner:");
        jPanel5.add(jLabel2);
        jLabel2.setBounds(10, 30, 70, 14);

        l_FLD_winner.setText("xxx");
        jPanel5.add(l_FLD_winner);
        l_FLD_winner.setBounds(100, 30, 140, 14);

        jLabel13.setText("FLD value: ");
        jPanel5.add(jLabel13);
        jLabel13.setBounds(10, 60, 70, 14);

        l_FLD_val.setText("vvv");
        jPanel5.add(l_FLD_val);
        l_FLD_val.setBounds(100, 60, 140, 14);

        getContentPane().add(jPanel5);
        jPanel5.setBounds(340, 10, 230, 130);

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void f_rb_selActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_f_rb_selActionPerformed
        f_combo_criterion.setEnabled(true);
        f_combo_PCA_LDA.setEnabled(false);
    }//GEN-LAST:event_f_rb_selActionPerformed

    private void f_rb_extrActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_f_rb_extrActionPerformed
        f_combo_criterion.setEnabled(false);
        f_combo_PCA_LDA.setEnabled(true);
    }//GEN-LAST:event_f_rb_extrActionPerformed

    private void b_readActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_readActionPerformed
        // reads in a text file; contents is placed into a variable of String type
        InData = readDataSet();


    }//GEN-LAST:event_b_readActionPerformed

    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton2ActionPerformed
        // Analyze text inputted from a file: determine class number and labels and number
        // of features; build feature matrix: columns - samples, rows - features
        try {
            if (InData != null) {
                getDatasetParameters();
                l_nfeatures.setText(FeatureCount + "");
                fillFeatureMatrix();
            }
        } catch (Exception ex) {
            JOptionPane.showMessageDialog(this, ex.getMessage());
        }

    }//GEN-LAST:event_jButton2ActionPerformed

    private void b_deriveFSActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_deriveFSActionPerformed

        //jeżeli nie sparsowano pliku do macierzy
        if (F == null) {
            return;
        }
        //jeżeli selekaja tą metodą co ją robiłem
        if (f_rb_sel.isSelected()) {
            // the chosen strategy is feature selection
            int[] flags = new int[FeatureCount];
            //(flagi, ilosc cech z inputu)
            selectFeatures(flags, Integer.parseInt((String) selbox_nfeat.getSelectedItem()));
        } else if (f_rb_extr.isSelected()) {
            l_FLD_winner.setText("ny");
            l_FLD_val.setText("ny");
            double TotEnergy = Double.parseDouble(tf_PCA_Energy.getText()) / 100.0;
            // Target dimension (if k>0) or flag for energy-based dimension (k=0)
            int k = 0;
            // F is an array of initial features, FNew is the resulting array
            double[][] FFNorm = centerAroundMean(F);
            Matrix Cov = computeCovarianceMatrix(FFNorm);
            Matrix TransformMat = extractFeatures(Cov, TotEnergy, k);
            FNew = projectSamples(new Matrix(FFNorm), TransformMat);
            // FNew is a matrix with samples projected to a new feature space
            l_NewDim.setText(FNew.length + "");
        }
    }//GEN-LAST:event_b_deriveFSActionPerformed

    private void b_TrainActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_b_TrainActionPerformed
        if (FNew == null) {
            return; // no reduced feature space have been derived
        }
        //ile % tablicy będzue treningowa
        double percentage = Double.parseDouble(tf_TrainSetSize1.getText()) / 100.0;

        //pokazuje całą tablitę TESTTTTTTTTTTTTT
        System.out.println("Cały: ");
        for (int i = 0; i < FNew.length; i++) {
            for (int j = 0; j < FNew[i].length; j++) {
                System.out.print(FNew[i][j] + " ");
            }
            System.out.println("");
        }

        //dzielimy ile ma być treningowych a ile testowych OBIEKTÓW
        //macierz a i macierz b mają mieć tyle samo testorych i treningowych (procentowo)
        int training[] = new int[2];
        int test[] = new int[2];
        training[0] = (int) round(SampleCount[0] * percentage);
        test[0] = SampleCount[0] - training[0];
        training[1] = (int) round(SampleCount[1] * percentage);
        test[1] = SampleCount[1] - training[1];

        //info kle testowych i ile treningowych
        testLAbel.setText("Wszystkie A: " + SampleCount[0] + ", wszystkie B: " + SampleCount[1]);
        testLAbel1.setText("Treningowe A: " + training[0] + ", treningowe B: " + training[1]);
        testLAbel2.setText("Testowe A: " + test[0] + ", testowe B: " + test[1]);

        //macierze treningowa i testowa 
        //macierz[iloscCechNp6][ilośćObiektowNp123]
        Ftrain = new double[FNew.length][(training[0] + training[1])];
        Ftest = new double[FNew.length][(test[0] + test[1])];

        //przelatuje przez kazdą cechę 1,2,3,4,5,6
        for (int i = 0; i < FNew.length; i++) {
            //przelatuje przez każdy obiekt 1,2,3,4,5,6,7,8,9,10...
            for (int j = 0; j < FNew[i].length; j++) {
                //jezeli obiekt nalezy do klasy A 
                if (ClassLabels[j] == 0) {
                    //jeżelio należy do zbioru treningowego
                    if (j < training[0]) {
                        //przypisuje go do zbioru treningowego
                        Ftrain[i][j] = FNew[i][j];
                    } //jeżeli należy do zbioru testowego
                    else {
                        Ftest[i][j - training[0]] = FNew[i][j];
                    }
                }
                //jeżeli należy do B
                if (ClassLabels[j] == 1) {
                    if (j < (training[1] + training[0] + test[0])) {
                        Ftrain[i][(j - test[0])] = FNew[i][j];
                    } else {
                        Ftest[i][(j - training[1] - training[0])] = FNew[i][j];
                    }
                }
            }
        }
        //vektor informujący który obiekt treningowy należy do danej cechy [0,0,0,0,1,1,1,1,1,1,1,1]
        FtrainSeparator2 = new int[(training[0] + training[1])];
        for (int i = 0; i < (training[0] + training[1]); i++) {
            if (i < training[0]) {
                FtrainSeparator2[i] = 0;
            } else {
                FtrainSeparator2[i] = 1;
            }
        }
        //vektor informujący który obiekt testowy należy do danej cechy [0,0,1,1,1]
        FtrainSeparator2test = new int[(test[0] + test[1])];
        for (int i = 0; i < (test[0] + test[1]); i++) {
            if (i < test[0]) {
                FtrainSeparator2test[i] = 0;
            } else {
                FtrainSeparator2test[i] = 1;
            }
        }

        //INFOOOOOOOOOOOOOOOOOOOOOO
        System.out.println("Treningowy: ");
        for (int i = 0; i < Ftrain.length; i++) {
            for (int j = 0; j < Ftrain[i].length; j++) {
                System.out.print("należy do:{" + FtrainSeparator2[j] + "} " + Ftrain[i][j] + " ");
            }
            System.out.println("");
        }
        System.out.println("Testowy: ");
        for (int i = 0; i < Ftest.length; i++) {
            for (int j = 0; j < Ftest[i].length; j++) {
                System.out.print("należy do:{" + FtrainSeparator2test[j] + "} " + Ftest[i][j] + " ");
            }
            System.out.println("");
        }
    }//GEN-LAST:event_b_TrainActionPerformed

    private void f_combo_criterionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_f_combo_criterionActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_f_combo_criterionActionPerformed

    private void jComboBox2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jComboBox2ActionPerformed
        if (jComboBox2.getSelectedItem().toString() == "k-Nearest Neighbor (k-NN)") {
            tf_winSize.setEnabled(true);
        } else {
            tf_winSize.setEnabled(false);
        }
    }//GEN-LAST:event_jComboBox2ActionPerformed

    private void f_rb_sel1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_f_rb_sel1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_f_rb_sel1ActionPerformed

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton4ActionPerformed
        listModel1 = new DefaultListModel();
        jList1.setModel(listModel1);

        //Testowe dane aby przyspieszyć testowanie
    /*    double[][] tr1 = {{1, 2, 2, 4, 1, 3, 3, 5}, {2, 5, 5, 7, 7, 9, 8, 6}, {3, 3, 4, 5, 1, 1, 2, 1}};
        double[][] te1 = {{1}, {7}, {3}};
        double[][] te2 = {{2}, {5}, {2}};
        double[][] te3 = {{3, 1, 2, 0, 3}, {1, 7, 5, 2, 1}, {2, 3, 2, 2, 2}};
        int[] s1 = {0, 0, 0, 0, 1, 1, 1, 1};
        int[] st1 = {0};
        int[] st3 = {0, 0, 1, 1, 1};
        ClassNames = new String[2];
        ClassNames[0] = "AA";
        ClassNames[1] = "BB";
*/
        if (jComboBox2.getSelectedItem().toString() == "Nearest neighbor (NN)") {
            listModel1.addElement("Nearest neighbor (NN)");
            classifierNN(Ftrain, Ftest, FtrainSeparator2, FtrainSeparator2test);
            //classifierNN(tr1, te3, s1, st3);
        } else if (jComboBox2.getSelectedItem().toString() == "Nearest Mean (NM)") {
            //listModel1.addElement("Nearest Mean (NM)");
            classifierNM(Ftrain, Ftest, FtrainSeparator2, FtrainSeparator2test);
           // classifierNM(tr1, te3, s1, st3);
        } else if (jComboBox2.getSelectedItem().toString() == "k-Nearest Neighbor (k-NN)") {
            listModel1.addElement("k-Nearest Neighbor (k-NN)");
            //classifierkNN(tr1, te3, s1, Integer.parseInt(tf_winSize.getText()), st3);
            classifierkNN(Ftrain, Ftest, FtrainSeparator2, Integer.parseInt(tf_winSize.getText()), FtrainSeparator2test);
        } else if (jComboBox2.getSelectedItem().toString() == "k-Nearest Mean (k-NM)") {
            listModel1.addElement("k-Nearest Mean (k-NM)");
        }

    }//GEN-LAST:event_jButton4ActionPerformed

    private void classifierNM(double[][] Ftrain, double[][] Ftest, int[] FtrainSeparator2, int[] FtrainSeparator2test) {
        if (Ftest == null) {
            return; // no reduced feature space have been derived
        }
        double Poprawnosc = 0;
        int FeCount[] = new int[2];

        //srednia[2 macierze][ilość cech np 3 cechy ...]
        //Sr[0] Macierz średnich A Sr[0]{sredniacecha1, sredniacecha2 ...}
        //Sr[1] Macierz średnich B 
        double Sr[][] = new double[2][Ftrain.length];

        //dodaje cechy obiektów ze swojej klasy
        for (int i = 0; i < Ftrain.length; i++) {
            for (int j = 0; j < Ftrain[0].length; j++) {
                //suma cech 
                Sr[FtrainSeparator2[j]][i] += Ftrain[i][j];
            }
        }
        //zlicza ilość cech //wcześniej też było to zliczone przy roździelaniu na część testową i treningową
        //dla łatwości sprawdzania liczę jeszcze raz 
        for (int i = 0; i < FtrainSeparator2.length; i++) {
            FeCount[FtrainSeparator2[i]]++;
        }
        System.out.println("Ilość cech A: "+FeCount[0]);
        System.out.println("Ilość cech B: "+FeCount[1]);
        //dzieli sumę przez ilość cech czyli mamy już średnią
        for (int i = 0; i < Sr.length; i++) {
            for (int j = 0; j < Sr[0].length; j++) {
                Sr[i][j] /= FeCount[i];
            }
        }

        //dla każdego punktu - obiektu testowego
        for (int i = 0; i < Ftest[0].length; i++) {//np 1 punkt testowy
            //double punktTestowy[] = Ftest[i];
            double resultA = 0;
            double resultB = 0;
            
            //wyliczanie wartości - sumuje cechy obiektu pomniejszone o średnią cechy
            System.out.println("Punk testowy: "+i+ "nalezal do "+ClassNames[FtrainSeparator2test[i]]);
            for (int j = 0; j < Ftrain.length; j++) {
                
                resultA += pow(Ftest[j][i] - Sr[0][j], 2);
                resultB += pow(Ftest[j][i] - Sr[1][j], 2);
            }
            resultA = sqrt(resultA);
            resultB = sqrt(resultB);
            System.out.println("A --> "+resultA);
            System.out.println("B --> "+resultB);

            if (resultA < resultB) {
                listModel1.addElement("P[" + i + "] nalezal do " + ClassNames[FtrainSeparator2test[i]] 
                    + " => " + ClassNames[0] + " -> " + resultA );
                if (FtrainSeparator2test[i] == 0) {
                    Poprawnosc++;
                }
            } else {
                listModel1.addElement("P[" + i + "] nalezal do " + ClassNames[FtrainSeparator2test[i]] 
                    + " => " + ClassNames[1] + " -> " + resultB);
                if (FtrainSeparator2test[i] == 1) {
                    Poprawnosc++;
                }
            }
        }
        double pop = (Poprawnosc / Ftest[0].length) * 100;
        listModel1.addElement("Poprawnosc: " + pop + "%");
        listModel1.addElement("Poprawnych: " + Poprawnosc + " testowych: " + Ftest[0].length);
        listModel1.addElement(FtrainSeparator2test.length);
    }

    public void b_sort(double[] tablica, int[] tabLabel) {
        int mniejszaLiczba = tablica.length - 1; // indeks pierwszej porownywanej liczby; wartosc poczatkowa
        int wiekszaLiczba = mniejszaLiczba - 1; // indeks drugiej porownywanej liczby; wartosc poczatkowa

        double tmp;
        int tmp2;
        int tmp3;
        while (wiekszaLiczba >= 0) // indeks drugiej porownywanej liczby musi byc nie mniejszy niz zero
        {
            if (tablica[wiekszaLiczba] > tablica[mniejszaLiczba]) // jesli druga liczba jest wieksza niz pierwsza
            {
                tmp = tablica[wiekszaLiczba];
                tablica[wiekszaLiczba] = tablica[mniejszaLiczba]; // zamien wartosci
                tablica[mniejszaLiczba] = tmp;

                tmp2 = tabLabel[wiekszaLiczba];
                tabLabel[wiekszaLiczba] = tabLabel[mniejszaLiczba]; // zamien wartosci
                tabLabel[mniejszaLiczba] = tmp2;

                mniejszaLiczba = tablica.length - 1;  // zresetuj licznik
                wiekszaLiczba = mniejszaLiczba - 1;   // zresetuj licznik
            } else // jesli druga liczba jest mniejsza lub rowna pierwszej, zmniejsz licznik o 1
            {
                mniejszaLiczba--;
                wiekszaLiczba--;
            }
        }
    }

    /**
     *
     * @param Ftrain zbior treningowy
     * @param Ftest zbior testowy
     * @param FtrainSeparator2 separator zbioru treningowego który obiekt do
     * której klasy
     * @param Kwin ile cech wygrywa
     * @param FtrainSeparator2test separator zbioru testowego który obiekt
     * należał do której klasy
     *
     */
    private void classifierkNN(double[][] Ftrain, double[][] Ftest, int[] FtrainSeparator2, int Kwin, int[] FtrainSeparator2test) {
        if (Ftest == null) {
            return; // no reduced feature space have been derived
        }
        //na wygrane wartości 
        double kWinTab[];
        //na wygrane klasy do których należały punkty  
        int kWinLabel[];
        double poprawnosc = 0;
        //przy sortowaniu będzie zmieniało kolejność równolegle z wartościami
        //       int FtrainSeparator2test2[] = FtrainSeparator2test;
        double currentWinVal = 0;
        int currentWinClass = 0;

        //dla każdego punktu - obiektu testowego
        for (int i = 0; i < Ftest[0].length; i++) {//np 1 punkt testowy
            //czyścimy po poprzednim punkcie testowym
            kWinTab = new double[Kwin];
            kWinLabel = new int[Kwin];
            //dla kazdego obiektu treningowego obliczamy bliskość z punktem testowym
            for (int j = 0; j < Ftrain[0].length; j++) {
                double result = 0.0;

                //odejmujemy od cech cechy punktu testowego podnosimy do potęgi tak jak we wzorze
                for (int c = 0; c < Ftrain.length; c++) {
                    result += pow(Ftest[c][i] - Ftrain[c][j], 2);
                }
                result = sqrt(result);

                //jeżeli jeszcze nie ma wystarczającej liczby punktów wygrywających przypisywane są kolejne
                if (j < Kwin) {
                    kWinTab[j] = result;
                    kWinLabel[j] = FtrainSeparator2[j];
                } //jeżeli lista wygrywających pełna
                else {
                    //sortuje od najwiekszych do najmniejszych
                    b_sort(kWinTab, kWinLabel);
                    //jeżeli bliższy punkt od któregoś z wygrywających
                    if (result < kWinTab[Kwin - 1]) {
                        kWinTab[Kwin - 1] = result;
                        kWinLabel[Kwin - 1] = FtrainSeparator2[j];
                    }
                }
            }
            //ilość wygranych z A i z B 
            int Awin = 0;
            int Bwin = 0;
            //jeżeli wygrana należy do B inkrementujemy
            for (int j = 0; j < kWinLabel.length; j++) { 
                System.out.println("P[" + i + "] " + "Winners[" + j + "] należy do: " + ClassNames[kWinLabel[j]]+" => " + kWinTab[j] );
                if (kWinLabel[j] == 0) {
                    Awin++;
                }
                if (kWinLabel[j] == 1) {
                    Bwin++;
                }
            }
            //czy bależy do A czy do B które ma więcej inkrementacji
            int nalezyDo;int councFeatureWin;
            if (Awin >= Bwin) {
                nalezyDo = 0;
                councFeatureWin = Awin;
            } else {
                nalezyDo = 1;
                councFeatureWin = Bwin;
            }
            listModel1.addElement("Ptestowy["+i+"] należał do => "+ClassNames[FtrainSeparator2test[i]]+" a "
                    + "teraz do => "+ClassNames[nalezyDo]+" ->cech: "+councFeatureWin);
            //czy należy do tego do czego wcześniej należał
            if (FtrainSeparator2test[i] == nalezyDo) {
                poprawnosc++;
            }

        }
        //przez te cechy do których należał i należy / wszystkie
        double pop = (poprawnosc / Ftest[0].length) * 100;
        listModel1.addElement("Poprawnosc: " + pop + "%");
    }

    /**
     *
     * @param Ftrain zbior treningowy
     * @param Ftest zbior punktow testowych p1, p2 ,p3
     * @param FtrainSeparator oddziela frtain na a i b
     */
    private void classifierNN(double[][] Ftrain, double[][] Ftest, int[] FtrainSeparator2, int[] FtrainSeparator2test) {
        if (Ftest == null) {
            return; // no reduced feature space have been derived
        }

        double poprawnosc = 0;
        double currentWinVal = 0;
        int currentWinClass = 0;

        //dla każdego punktu - obiektu testowego
        for (int i = 0; i < Ftest[0].length; i++) {//np 1 punkt testowy
            //jeżeli jeszcze nie ma żadnego punktu wygrywającego wygrywającym jest pierwszy
            boolean Nnew = true;

            //dla kazdego obiektu treningowego obliczamy bliskość z punktem testowym
            for (int j = 0; j < Ftrain[0].length; j++) {
                double result = 0.0;
                //odejmujemy od cechy ceche punktu testowegi podnosimy do potęgi tak jak we wzorze
                for (int c = 0; c < Ftrain.length; c++) {
                    result += pow(Ftest[c][i] - Ftrain[c][j], 2);
                }
                //jak we wzorze
                result = sqrt(result);

                //jeżeli jeszcze nie ma żadnego punktu wygrywającego wygrywającym jest pierwszy
                if (Nnew) {
                    currentWinVal = result;
                    currentWinClass = FtrainSeparator2[j];
                    Nnew = false;
                } //przypisuje najmniejszą wartość jako wygrywającą
                //i klasę do której należy
                else if (currentWinVal > result) {
                    currentWinVal = result;
                    currentWinClass = FtrainSeparator2[j];
                    System.out.println(ClassNames[currentWinClass] + " wynik dla P" + i + " obiekt" + j + " = " + result);
                }
            }
            //jeżeli ma blizej do klasy do której należał inkrementujemy
            if (FtrainSeparator2test[i] == currentWinClass) {
                poprawnosc++;
            }
            listModel1.addElement("P[" + i + "] nalezal do " + ClassNames[FtrainSeparator2test[i]] + " => " + ClassNames[currentWinClass] + " -> " + currentWinVal);
        }
        //liczymy poprawność tyle przypadki w których punkt został przydzielony do klasy do której należał / wszystkie
        double pop = (poprawnosc / Ftest[0].length) * 100;
        listModel1.addElement("Poprawnosc: " + pop + "%");
        listModel1.addElement("Poprawnych: " + poprawnosc + " testych: " + Ftest[0].length);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new PR_GUI().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton b_Train;
    private javax.swing.JButton b_deriveFS;
    private javax.swing.JButton b_read;
    private javax.swing.JComboBox f_combo_PCA_LDA;
    private javax.swing.JComboBox f_combo_criterion;
    private javax.swing.JRadioButton f_rb_extr;
    private javax.swing.JRadioButton f_rb_sel;
    private javax.swing.JRadioButton f_rb_sel1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton4;
    private javax.swing.JComboBox jComboBox2;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel10;
    private javax.swing.JLabel jLabel12;
    private javax.swing.JLabel jLabel13;
    private javax.swing.JLabel jLabel14;
    private javax.swing.JLabel jLabel15;
    private javax.swing.JLabel jLabel16;
    private javax.swing.JLabel jLabel18;
    private javax.swing.JLabel jLabel19;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JLabel jLabel9;
    private javax.swing.JList jList1;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JLabel l_FLD_val;
    private javax.swing.JLabel l_FLD_winner;
    private javax.swing.JLabel l_NewDim;
    private javax.swing.JLabel l_dataset_name;
    private javax.swing.JLabel l_dataset_name_l;
    private javax.swing.JLabel l_nfeatures;
    private javax.swing.ButtonGroup rbg_F;
    private javax.swing.JComboBox selbox_nfeat;
    public javax.swing.JLabel testLAbel;
    public javax.swing.JLabel testLAbel1;
    public javax.swing.JLabel testLAbel2;
    private javax.swing.JTextField tf_PCA_Energy;
    private javax.swing.JTextField tf_TrainSetSize1;
    private javax.swing.JTextField tf_winSize;
    // End of variables declaration//GEN-END:variables

    private String readDataSet() {

        String s_tmp, s_out = "";
        JFileChooser jfc = new JFileChooser();
        jfc.setCurrentDirectory(new File(".."));
        FileNameExtensionFilter filter = new FileNameExtensionFilter(
                "Datasets - plain text files", "txt");
        jfc.setFileFilter(filter);
        if (jfc.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                BufferedReader br = new BufferedReader(new FileReader(jfc.getSelectedFile()));
                while ((s_tmp = br.readLine()) != null) {
                    s_out += s_tmp + '$';
                }
                br.close();
                l_dataset_name.setText(jfc.getSelectedFile().getName());
            } catch (Exception e) {
            }
        }
        return s_out;
    }

    private void getDatasetParameters() throws Exception {
        // based on data stored in InData determine: class count and names, number of samples 
        // and number of features; set the corresponding variables
        String stmp = InData, saux = "";
        // analyze the first line and get feature count: assume that number of features
        // equals number of commas
        saux = InData.substring(InData.indexOf(',') + 1, InData.indexOf('$'));
        if (saux.length() == 0) {
            throw new Exception("The first line is empty");
        }
        // saux stores the first line beginning from the first comma
        int count = 0;
        while (saux.indexOf(',') > 0) {
            saux = saux.substring(saux.indexOf(',') + 1);
            count++;
        }
        FeatureCount = count + 1; // the first parameter
        // Determine number of classes, class names and number of samples per class
        boolean New;
        int index = -1;
        List<String> NameList = new ArrayList<String>();
        List<Integer> CountList = new ArrayList<Integer>();
        List<Integer> LabelList = new ArrayList<Integer>();
        while (stmp.length() > 1) {
            saux = stmp.substring(0, stmp.indexOf(' '));
            New = true;
            index++; // new class index

            //nie wykona sie przy pierwszej linii
            for (int i = 0; i < NameList.size(); i++) {
                if (saux.equals(NameList.get(i))) {
                    New = false;
                    index = i; // class index
                }
            }

            if (New) {
                NameList.add(saux);
                CountList.add(0);
            } else {
                CountList.set(index, CountList.get(index).intValue() + 1);
            }
            LabelList.add(index); // class index for current row
            stmp = stmp.substring(stmp.indexOf('$') + 1);
        }

        // based on results of the above analysis, create variables
        ClassNames = new String[NameList.size()];
        for (int i = 0; i < ClassNames.length; i++) {

            ClassNames[i] = NameList.get(i);
            //System.out.println(ClassNames[i]);
        }
        // System.out.println("startttttttttttt");
        // System.out.println(JsonWriter.formatJson(ClassNames));

        SampleCount = new int[CountList.size()];
        for (int i = 0; i < SampleCount.length; i++) {
            SampleCount[i] = CountList.get(i).intValue() + 1;
            //System.out.println(SampleCount[i]);
        }
        ClassLabels = new int[LabelList.size()];
        for (int i = 0; i < ClassLabels.length; i++) {
            ClassLabels[i] = LabelList.get(i).intValue();
            //System.out.println(ClassLabels[i]);
        }
    }

    private void fillFeatureMatrix() throws Exception {
        // having determined array size and class labels, fills in the feature matrix
        int n = 0;
        String saux, stmp = InData;
        for (int i = 0; i < SampleCount.length; i++) {
            n += SampleCount[i];
        }
        if (n <= 0) {
            throw new Exception("no samples found");
        }
        F = new double[FeatureCount][n]; // samples are placed column-wise
        for (int j = 0; j < n; j++) {
            saux = stmp.substring(0, stmp.indexOf('$'));
            saux = saux.substring(stmp.indexOf(',') + 1);
            for (int i = 0; i < FeatureCount - 1; i++) {
                F[i][j] = Double.parseDouble(saux.substring(0, saux.indexOf(',')));
                //System.out.print(F[i][j]+" ");
                saux = saux.substring(saux.indexOf(',') + 1);
            }

            F[FeatureCount - 1][j] = Double.parseDouble(saux);//ostatnie pole bo po nim nie ma przecinka czyli to co w petli
            // System.out.print(F[FeatureCount - 1][j]+" ");
            stmp = stmp.substring(stmp.indexOf('$') + 1);
        }
        int cc = 1;
    }

    private void selectFeatures(int[] flags, int d) {
        //dla 1 cechy nie moja metoda
        if (d == 1) {
            double FLD = 0, tmp;
            int max_ind = -1;
            for (int i = 0; i < FeatureCount; i++) {
                if ((tmp = computeFisherLD(F[i])) > FLD) {
                    FLD = tmp;
                    max_ind = i;
                }
            }
            l_FLD_winner.setText(max_ind + "");
            l_FLD_val.setText(FLD + "");
        } else {
            //Metoda SFS włączona
            boolean SFS_ = true;

            //działą zwykłą metodą bez SFS dla  większych danych nie policzy 
            if (!SFS_) {
                int winners[];
                //wszystkie możliwe kombinacje bez powtórzeń (d elementowe) zapisuje do listy: listaBezPowt
                combinations(new int[d], d, 0);
                double FLD = 0, tmp;
                System.out.println("Liczba kombinacji: " + listaBezPowt.size());
                //dla każdej kombinacji liczy współczynnik Fishera 
                for (int[] someCombination : listaBezPowt) {
                    //zapisuje i wypisuje najlepszą kombinację 
                    if ((tmp = computeFisherLDfull(someCombination)) > FLD) {
                        FLD = tmp;
                        winners = someCombination;
                        String tmpx = "";
                        for (int i = 0; i < winners.length; i++) {
                            tmpx = tmpx + " " + winners[i];
                        }
                        l_FLD_winner.setText(tmpx);
                        l_FLD_val.setText(FLD + "");
                    }
                };
            } else {
                //wszystkie możliwe kombinacje bez powtórzeń (2 - elementowe) zapisuje do listy: listaBezPowt
                //zaczybamy liczyć od dwóch więc później dla metody SFS będziemy liczyć tylko najlepsze kombinacje 
                combinations(new int[2], 2, 0);
                //najlepszy współczynnik fishera dla danej cechy
                double FLD = 0;
                //najlepsza kombinacja cech 
                int[] best = null;
                //aktualnie liczony współczynnik fishera 
                double tmp;

                //liczymy współczynnik fishera dla tylu cech ilu podaliśmy w inpucie
                //dla 2 --> dla 3 --> ... dla podanej wartości
                for (int i = 2; i <= d; i++) {

                    //Zerujemy współczynnik dla kolejnej ilości cech bo liczymy od nowa dla każdej kombinacji w danej ilości
                    FLD = 0;
                    System.out.println("Obliczam współczynnik dla kombinacji z " + i + " cech.");

                    //liczymy dla kazdej mozliwej kombinacji która znajduje się w liście
                    for (int[] someCombination : listaBezPowt) {

                        //liczy współczynnik i zapisuje najlepszy do FLD a kombinację przy której był najlepszy do best
                        if ((tmp = computeFisherLDfull(someCombination)) > FLD) {
                            FLD = tmp;
                            best = someCombination;

                            String tmpx = "";
                            for (int ii = 0; ii < best.length; ii++) {
                                tmpx = tmpx + " " + best[ii];
                            }
                            l_FLD_winner.setText(tmpx);
                            l_FLD_val.setText(FLD + "");
                        }
                    }

                    //jeżeli obliczenia były z kombinacji cech mniejszej niż podana w inpucie 
                    //generujemy nową listę kombinacji większą o 1 cechę która zaczyna się od wygranych cech
                    if (d != i) {
                        combinationsBest(best, i);
                    }

                }
                //Tworzymy macirz wygrywających cech dla klasyfikatorów
                //[ilość cech taka jak z inputu te co wygrały][ilość obiektów 780]
                FNew = new double[best.length][F[0].length];
                //dopóki cecha ma obiekt
                for (int i = 0; i < best.length; i++) {
                    FNew[i] = F[best[i]];
                }

            }

        }
    }

    /**
     * Liczy współcznyyik fishera dla dowolnej kombinacji cech
     *
     * @param kombinacjaCech tablica zawierająca kombinacę cech (numery cech)
     * @return
     */
    private double computeFisherLDfull(int[] kombinacjaCech) {
        double mA = 0, mB = 0, sA = 0, sB = 0;
        int licznikA = 0, licznikB = 0;

        //tablica średnich dla cech
        double sredniaA[] = new double[kombinacjaCech.length];
        double sredniaB[] = new double[kombinacjaCech.length];

        //nowa tablica taka jak F tylko z samymi cechami z których liczymy
        //wektor_cech[obiektów][cech]
        double[][] wektor_cechA = new double[kombinacjaCech.length][SampleCount[0]];
        double[][] wektor_cechB = new double[kombinacjaCech.length][SampleCount[1]];

        //tablica na średnie
        double tabSrednieA[][] = new double[kombinacjaCech.length][SampleCount[0]];
        double tabSrednieB[][] = new double[kombinacjaCech.length][SampleCount[1]];

        //Macierze gotowe do wyliczenia wyznacznika
        Matrix macierzA;
        Matrix macierzB;

        double sredniaA_B[] = new double[kombinacjaCech.length];

        //tyle razy ile jest obiektów 784
        //przelatuje przez całą długość macierzy [1,2,1,2,4,2,1,2,4,2,1,35,2,34,53,2] czyli ilość obiektów
        for (int i = 0; i < F[kombinacjaCech[0]].length; i++) {
            //dany obiekt należy do macierzy A
            if (ClassLabels[i] == 0) {
                //przelatuję przez każdą cechę z kombinacji dla danego obiektu
                //Kombinacja => 12,45,51
                //sredniaA[0] += F[12][i]
                //sredniaA[1] += F[45][i]
                //sredniaA[2] += F[51][i]
                //wektor_cechA[0][i] = F[12][i]
                //wektor_cechA[1][i] = F[45][i]
                //wektor_cechA[2][i] = F[51][i]
                for (int j = 0; j < sredniaA.length; j++) {
                    //dodaje do sredniej[danaCecha] jej wartość z kolejnego obiektu czyli z 784 obiektów ( - te z B )
                    sredniaA[j] += F[kombinacjaCech[j]][i];
                    //nowa tablica taka jak F tylko z samymi cechami z których liczymy
                    wektor_cechA[j][licznikA] = F[kombinacjaCech[j]][i];
                }
                //zwiększamy index dla wektora czyli nowej tablicy jak F tylko z samymi cechami z których liczymy
                licznikA++;
            } //To samo dla Klasy B
            else {
                for (int j = 0; j < sredniaA.length; j++) {
                    sredniaB[j] += F[kombinacjaCech[j]][i];
                    wektor_cechB[j][licznikB] = F[kombinacjaCech[j]][i];
                }
                licznikB++;
            }
        }

        //oblicza średnie czyli dzielimy sumę cech przez ich ilość
        for (int j = 0; j < sredniaA.length; j++) {
            sredniaA[j] /= SampleCount[0];
            sredniaB[j] /= SampleCount[1];
        }

        //Robimy tablicę (macierz) ze średnich
        //dla 3 cech i 5 obiektów
        //  [1]     [1][1][1][1][1]
        //z [3] ==> [3][3][3][3][3]
        //  [2]     [2][2][2][2][2]
        //dla każdej cechy
        for (int j = 0; j < kombinacjaCech.length; j++) {
            //dla każdego obiektu A 780-160
            for (int i = 0; i < SampleCount[0]; i++) {
                tabSrednieA[j][i] = sredniaA[j];
            }
            for (int i = 0; i < SampleCount[1]; i++) {
                tabSrednieB[j][i] = sredniaB[j];;
            }
        }

        //Klasa macierze tablicowe na klasę aby przyspieszyć obliczenia (pisanie kodu)
        Matrix tmpA = new Matrix(wektor_cechA);
        Matrix tmpB = new Matrix(wektor_cechB);
        Matrix tmpA2 = new Matrix(tabSrednieA);
        Matrix tmpB2 = new Matrix(tabSrednieB);

        //Macierze gotowe do wyliczenia wyznacznika
        macierzA = tmpA.minus(tmpA2).times((tmpA.minus(tmpA2)).transpose());
        macierzB = tmpB.minus(tmpB2).times((tmpB.minus(tmpB2)).transpose());

        //liczy wyznaczniki
        double wyzA = macierzA.det();
        double wyzB = macierzB.det();

        //srednia - srednia do góry równania sredniaA[cecha] - sredniaB[cecha]
        for (int j = 0; j < sredniaA.length; j++) {
            sredniaA_B[j] = sredniaA[j] - sredniaB[j];
        }

        double goraRownania = 0.0;
        //obliczneie góryt równania
        double tmp = pow((sredniaA_B[0]), 2);
        for (int j = 1; j < sredniaA_B.length; j++) {
            tmp += pow((sredniaA_B[j]), 2);//System.out.print(" - " +sredniaSrednia[j]);
        }
        goraRownania = sqrt(tmp);

        //zwraca wynik równania góra / dół
        return abs(goraRownania / (wyzA + wyzB));
    }

    /**
     * Pobiera aktualnie najlepszy zestaw cech i na jego podstawie tworzy nową
     * kombinację cech
     *
     * @param best aktualny zestaw cech
     * @param size rozmiar aktualnie najlepszego zestawu cech
     */
    private void combinationsBest(int[] best, int size) {
        //usuwa stary mniejszy zestaw cech 
        listaBezPowt.clear();
        //tyle będzie możliwych kombinacji czyli tyle ile cech
        for (int i = 0; i < FeatureCount; i++) {
            boolean check = true;
            //tablica na nową aktualną kombinacje cech { staraKombinacja, nowy element}
            int tmp[] = new int[size + 1];
            //przepisuje wartości i dodaje nową
            for (int j = 0; j <= size; j++) {
                //jeżeli już przepisało całą starą kombinację dodaje nowy element
                if (j == size) {
                    tmp[j] = i;
                    //wywala powtórzenia
                    for (int zz = 0; zz < size; zz++) {
                        if (i == tmp[zz]) {
                            check = false;
                        }
                    }
                } //przepisuje
                else {
                    tmp[j] = best[j];
                }
            }
            //jeżeli się noe powtarza dodaje do listy
            if (check) {
                listaBezPowt.add(tmp);
            }
        }
    }

    /**
     * Liczy wszystkie możliwe kombinacje d-elementowe bez powtórzeń z ilości
     *
     * @param comb pomocznicza zmienna dla rekurencji przechowywuje aktualny
     * stan danej kombinacji
     * @param d ilu elementowe kombinacje
     * @param start pomocznicza zmienna dla rekurencji przechowywuje aktualny
     * stan danej kombinacji
     */
    private void combinations(int[] comb, int d, int start) {
        //tyle będzie możliwych kombinacji 
        for (int i = 0; i < FeatureCount; i++) {
            //brak powtórzeń tych samych wartości
            boolean check = true;
            for (int istniejacyElement = 0; istniejacyElement < start; istniejacyElement++) {
                if (i == comb[istniejacyElement]) {
                    check = false;
                }
            }

            //Jeżeli nie powtarza się jeszcze ta kombinacja
            if (check) {
                //dopisuje nowy element do kombinacji 
                comb[start] = i;
                //jeżeli jest to już pełna kombinacja dodaję do listy
                if (d - 1 == start) {
                    int newComb[] = new int[comb.length];
                    System.arraycopy(comb, 0, newComb, 0, comb.length);
                    listaBezPowt.add(newComb);
                } //jeżeli jeszcze nie jest pełna (d-elementowa) odpal rekurencyjnie dodanie kolejnego elementu
                else {
                    combinations(comb, d, start + 1);
                }
            }
        }

    }

    private double computeFisherLD(double[] vec) {
        // 1D, 2-classes
        double mA = 0, mB = 0, sA = 0, sB = 0;
        //System.out.println("start--");
        for (int i = 0; i < vec.length; i++) {
            if (ClassLabels[i] == 0) {
                mA += vec[i];//System.out.print("-A-"+vec[i]+"-A-");
                sA += vec[i] * vec[i];
            } else {
                mB += vec[i];//System.out.print("-B-"+vec[i]+"-B-");
                sB += vec[i] * vec[i];
            }
        }
        mA /= SampleCount[0];//srednia
        mB /= SampleCount[1];//srednia
        sA = sA / SampleCount[0] - mA * mA;
        sB = sB / SampleCount[1] - mB * mB;//System.out.println("---------"+Math.abs(mA - mB)+"/"+Math.sqrt(sA)+"+"+Math.sqrt(sB));
        System.out.println("---------" + (Math.abs(mA - mB) / (Math.sqrt(sA) + Math.sqrt(sB))));
        return Math.abs(mA - mB) / (Math.sqrt(sA) + Math.sqrt(sB));
    }

    private Matrix extractFeatures(Matrix C, double Ek, int k) {

        Matrix evecs, evals;
        // compute eigenvalues and eigenvectors
        evecs = C.eig().getV();
        evals = C.eig().getD();

        // PM: projection matrix that will hold a set dominant eigenvectors
        Matrix PM;
        if (k > 0) {
            // preset dimension of new feature space
//            PM = new double[evecs.getRowDimension()][k];
            PM = evecs.getMatrix(0, evecs.getRowDimension() - 1,
                    evecs.getColumnDimension() - k, evecs.getColumnDimension() - 1);
        } else {
            // dimension will be determined based on scatter energy
            double TotEVal = evals.trace(); // total energy
            double EAccum = 0;
            int m = evals.getColumnDimension() - 1;
            while (EAccum < Ek * TotEVal) {
                EAccum += evals.get(m, m);
                m--;
            }
            PM = evecs.getMatrix(0, evecs.getRowDimension() - 1, m + 1, evecs.getColumnDimension() - 1);
        }

        /*            System.out.println("Eigenvectors");                
         for(int i=0; i<r; i++){
         for(int j=0; j<c; j++){
         System.out.print(evecs[i][j]+" ");
         }
         System.out.println();                
         }
         System.out.println("Eigenvalues");                
         for(int i=0; i<r; i++){
         for(int j=0; j<c; j++){
         System.out.print(evals[i][j]+" ");
         }
         System.out.println();                
         }
         */
        return PM;
    }

    private Matrix computeCovarianceMatrix(double[][] m) {
//        double[][] C = new double[M.length][M.length];

        Matrix M = new Matrix(m);
        Matrix MT = M.transpose();
        Matrix C = M.times(MT);
        return C;
    }

    private double[][] centerAroundMean(double[][] M) {

        double[] mean = new double[M.length];
        for (int i = 0; i < M.length; i++) {
            for (int j = 0; j < M[0].length; j++) {
                mean[i] += M[i][j];
            }
        }
        for (int i = 0; i < M.length; i++) {
            mean[i] /= M[0].length;
        }
        for (int i = 0; i < M.length; i++) {
            for (int j = 0; j < M[0].length; j++) {
                M[i][j] -= mean[i];
            }
        }
        return M;
    }

    private double[][] projectSamples(Matrix FOld, Matrix TransformMat) {

        return (FOld.transpose().times(TransformMat)).transpose().getArrayCopy();

    }
}

class Classifier {

    double[][] TrainingSet, TestSet;
    int[] ClassLabels;
    final int TRAIN_SET = 0, TEST_SET = 1;

    void generateTraining_and_Test_Sets(double[][] Dataset, String TrainSetSize) {

        int[] Index = new int[Dataset[0].length];
        double Th = Double.parseDouble(TrainSetSize) / 100.0;
        int TrainCount = 0, TestCount = 0;
        for (int i = 0; i < Dataset[0].length; i++) {
            if (Math.random() <= Th) {
                Index[i] = TRAIN_SET;
                TrainCount++;
            } else {
                Index[i] = TEST_SET;
                TestCount++;
            }
        }
        TrainingSet = new double[Dataset.length][TrainCount];
        TestSet = new double[Dataset.length][TestCount];
        TrainCount = 0;
        TestCount = 0;
        // label vectors for training/test sets
        for (int i = 0; i < Index.length; i++) {
            if (Index[i] == TRAIN_SET) {
                System.arraycopy(Dataset[i], 0, TrainingSet[TrainCount++], 0, Dataset[0].length);
            } else {
                System.arraycopy(Dataset[i], 0, TestSet[TestCount++], 0, Dataset[0].length);
            }
        }
    }

    protected void trainClissifier(double[][] TrainSet) {

    }

}

class NNClassifier extends Classifier {

    @Override
    protected void trainClissifier(double[][] TrainSet) {

    }
}
